{
	"Shader": {
		"ver": "0.1",
		"info": {
			"id": "MtsXRX",
			"date": "1439066444",
			"viewed": 813,
			"name": "[SIG15] Earthbound VR",
			"username": "RavenWorks",
			"description": "Based partly on work I did before the compo was announced, but now with greatly expanded content!<br/>I always wondered what it would be like to be 'in' these scenes...<br/>Kind of a mishmash of scenes throughout the game because I couldn't pick just one :P",
			"likes": 8,
			"published": 3,
			"flags": 9,
			"tags": [
				"game",
				"raymarch",
				"retro",
				"snes",
				"vr",
				"compo",
				"earthbound",
				"rpg",
				"sig15"
			],
			"hasliked": 0
		},
		"renderpass": [
			{
				"inputs": [],
				"outputs": [],
				"code": "",
				"name": "",
				"description": "",
				"type": "image"
			},
			{
				"inputs": [],
				"outputs": [],
				"code": "//sync with image\nconst float encounterStart = 9.2;\nconst float transitionStart = encounterStart+0.25;\nconst float transitionEnd = transitionStart+3.0;\n\n\n\nconst float pi = 3.14159;\nconst float pi2 = pi*2.0;\n\nvec2 pan(float panAmt){\n    return vec2(0.5-panAmt*0.5,0.5+panAmt*0.5);\n}\n\nfloat noteFreq(int note){\n    float oct = 1.0;\n    for(int octrange = 0; octrange<3; octrange++){\n        if (note >= 12) {\n            note -= 12;\n            oct *= 2.0;\n        }\n        if (note < 0) {\n            note += 12;\n            oct *= 0.5;\n        }\n    }\n    if (note ==  0) return oct*440.000;\n    if (note ==  1) return oct*466.164;\n    if (note ==  2) return oct*493.883;\n    if (note ==  3) return oct*523.251;\n    if (note ==  4) return oct*554.365;\n    if (note ==  5) return oct*587.330;\n    if (note ==  6) return oct*622.254;\n    if (note ==  7) return oct*659.255;\n    if (note ==  8) return oct*698.456;\n    if (note ==  9) return oct*739.989;\n    if (note == 10) return oct*391.995*2.0;\n    if (note == 11) return oct*415.305*2.0;\n    return 0.0;\n}\n\n\nfloat introHorn(int note, float time){\n    \n    float glissandoTime = time - 0.5;\n    if (glissandoTime < 0.0) {\n        glissandoTime = -pow(1.0-glissandoTime,1.0-glissandoTime*0.4);\n    } else {\n        glissandoTime = -(1.0-glissandoTime);\n    }\n    \n    float baseFreq = 6.2831*noteFreq(note)*glissandoTime*0.5;\n    \n    float mix = 0.0;\n    \n    mix += sin(baseFreq*1.0)*1.0;\n    mix += sin(baseFreq*2.0)*0.75;\n    mix += sin(baseFreq*3.0)*0.75;\n    mix += sin(baseFreq*4.0)*0.5;\n    mix += sin(baseFreq*5.0)*0.75;\n    mix += sin(baseFreq*6.0)*0.5;\n    \n    mix *= 0.25;\n    \n    return mix;\n    \n}\n\n\nconst float beatLength = 1.0/7.5;\n\nfloat krakenSynth(int note, float time, float octave, float sawTweak){\n    \n    float baseFreq = noteFreq(note);\n    \n    float sinFreq = baseFreq*pow(2.0,octave+2.0);\n    float sawFreq = baseFreq*pow(2.0,octave-3.0-sawTweak);\n    \n    float sinWave = cos(6.2831*time*sinFreq);\n    float sawWave = 1.0-mod(time*sawFreq,1.0);\n    sawWave = pow(sawWave,8.0);\n    \n    return sawWave*sinWave - sawWave;\n    \n}\n\nfloat krakenLead(float songTime){\n    \n    float beatNum = songTime/beatLength;\n    float beatStep = mod(floor(beatNum),32.0);\n    float barStep = floor(beatNum/32.0);\n\n\n    if (mod(beatNum,1.0)<0.68){\n\n        float triplet = floor(beatStep/3.0);\n        float withinTriplet = mod(beatStep,3.0);\n        if (beatStep >= 16.0) {\n            triplet = 5.0-floor((beatStep-16.0)/3.0);\n            withinTriplet = mod(beatStep-16.0,3.0);\n        }\n        if (beatStep >= 29.0) {\n            withinTriplet++;\n        }\n\n\n\n        int curNote = 3;\n        if ((barStep > 0.0) && (mod(barStep,2.0)==0.0)) curNote += 4;\n\n        float octave = -triplet;\n        if (withinTriplet == 2.0) octave++;\n\n        return krakenSynth(curNote,mod(songTime,beatLength),octave,-triplet);\n\n    } else {\n        \n        return 0.0;\n        \n    }\n    \n}\n\n\nfloat bassSynth(int note, float time){\n    \n    const float noteLength = 0.5;\n    \n    if (time > noteLength) return 0.0;\n    \n    float baseFreq = 6.2831*time*noteFreq(note);\n    \n    float fadeIn = 1.0-pow(1.0-(time/noteLength),32.0);\n    float fadeOut = 1.0-pow(time/noteLength,8.0);\n    \n    return (\n        sin(baseFreq*pow(2.0,-6.0))*1.5 +\n        sin(baseFreq*pow(2.0,-5.0))*0.5 + \n        sin(baseFreq*pow(2.0,-4.0))*0.05\n    )*fadeIn*fadeOut;\n    \n}\n\nfloat krakenBass(float songTime){\n    \n    // this redundancy isn't great but whatev\n    float beatNum = songTime/beatLength;\n    float beatStep = mod(floor(beatNum),8.0);//DIFFERENT BAR LENGTH FOR BASSLINE\n    float barStep = mod(floor(beatNum/8.0),4.0);\n    \n    if ( beatStep == 3.0 && barStep < 2.0) return 0.0;\n    if ( beatStep == 6.0 && barStep < 3.0) return 0.0;\n    if ( beatStep == 7.0 && barStep == 3.0) return 0.0;\n    \n    int bassNote = (mod(floor(beatNum/32.0),2.0) == 0.0) ? 8 : 4 ;\n    \n    return bassSynth(bassNote, mod(beatNum,1.0));\n    \n}\n\n\nfloat wailSynth(int note, float time){\n    \n    const float noteEnd = 32.0;\n    const float noteStart = 4.0;\n    \n    float noteFrac = max(0.0,min(1.0,(time-noteStart)/(noteEnd-noteStart)));\n    float fadeIn = pow(noteFrac,2.0);\n    float fadeOut = 1.0-(pow(noteFrac,2.0));\n    \n    float baseFreq = 6.2831*time*noteFreq(note)*0.25;\n    baseFreq += sin(time*4.5)*3.0;\n    \n    return (\n        sin(baseFreq)+\n        sin(baseFreq*3.0)+\n        sin(baseFreq*4.0)*0.75\n    )*fadeIn*fadeOut*0.5;\n    \n}\n\nfloat krakenWail(float songTime){\n    \n    float beatNum = songTime/beatLength;\n    \n    int wailNote = (mod(floor(beatNum/32.0),2.0) == 0.0) ? 2 : 3;\n    \n    return wailSynth(wailNote, mod(beatNum,32.0));\n    \n}\n\n\nfloat noise(float time){\n    return sin( time*200034.2666 * sin(time*600078.6576) );\n}\n\nfloat kick(float time) {\n    \n    float sinWave = sin(pow(time*1000.0,0.6));\n    \n    const float fadeInTime = 0.00015;\n    float fadeIn = max(0.0,min(1.0,(time/fadeInTime)));\n    \n    const float fadeOutTime = 1.0;\n    float fadeOut = max(0.0,min(1.0,((fadeOutTime-time)/fadeOutTime)));\n    \n    return sinWave*fadeIn*fadeOut;\n    \n}\n\nfloat snare(float time) {\n    \n    float sinWave = sin(pow(time*1000.0,0.7));\n    float sineFadeIn = max(0.0,min(1.0,(time/0.00015)));\n    float sineFadeOut = max(0.0,min(1.0,(1.0-(time/0.25))));\n    \n    float noiseWave = noise(time);\n    float noiseFadeIn = max(0.0,min(1.0,(time/0.00015)));\n    float noiseFadeOut = max(0.0,min(1.0,(1.0-(time/0.25))));\n    \n    return noiseWave*noiseFadeIn*noiseFadeOut*0.75 + sinWave*sineFadeIn*sineFadeOut*0.5;\n    \n}\n\nfloat hihatClosed(float time){\n    \n    float sinWaveA = sin(pow(time*8700.0,0.99));\n    float sinWaveB = sin(pow(time*7200.0,0.99));\n    float sineFadeIn = max(0.0,min(1.0,(time/0.15)));\n    float sineFadeOut = max(0.0,min(1.0,(1.0-(time))));\n    \n    float noiseWave = noise(time);\n    float noiseFadeOut = max(0.0,min(1.0,(1.0-(time/0.75))));\n    noiseFadeOut = pow(noiseFadeOut,2.0);\n    \n    return noiseWave*noiseFadeOut*0.5 + (sinWaveA+sinWaveB)*sineFadeIn*sineFadeOut*0.05;\n    \n}\n\nfloat hihatOpen(float time){\n    \n    float noiseVol;\n    float sineVolA;\n    float sineVolB;\n    \n    if (time < 0.125) {\n    \t\n        noiseVol = 2.0;\n        \n        sineVolA = 0.1;\n        sineVolB = 0.15;\n        \n    } else if (time < 1.0) {\n        \n        noiseVol = 0.6;\n        \n        sineVolA = 0.1;\n        sineVolB = 0.15;\n        \n    } else if (time < 2.0) {\n        \n        noiseVol = max(0.0,min(1.0,(2.0-(time*1.0))));\n        noiseVol = pow(1.0-noiseVol,1.0);\n        noiseVol *= 0.1;\n        \n        sineVolA = max(0.0,min(1.0,(2.0-(time*0.5))));\n        sineVolA = 1.0-pow(1.0-sineVolA,1.0);\n        sineVolA *= 0.0125;\n        \n        sineVolB = sineVolA*1.5;\n        \n    } else {\n        \n        return 0.0;\n        \n    }\n    \n    float mix = 0.0;\n    \n    mix += noise(time)*noiseVol;\n    \n    mix += sin(time*6300.0) * sineVolA;\n    mix += sin(time*7200.0) * sineVolB;\n    \n    return mix;\n    \n}\n\n\n\nstruct portaTone {\n    float startFreq;\n    float endFreq;\n    \n    float startTime;\n    float endTime;\n};\n\nportaTone portaNote(int startNote, int endNote, float startTime, float endTime){\n    return portaTone(noteFreq(startNote)*pi2,noteFreq(endNote)*pi2,startTime,endTime);\n}\n\nfloat portaMiddleTime(float x, portaTone note){\n    \n    float newX = x-note.startTime;\n    float withinFrac = newX/(note.endTime-note.startTime);\n    \n    newX /= note.startFreq;\n    newX *= mix(note.startFreq,note.endFreq,withinFrac*0.5);\n\n    newX += note.startTime;\n\n    return newX;\n    \n}\nfloat playPortamento(float x, portaTone note){\n    \n    if (x < note.startTime) {\n        return sin(x*note.startFreq);\n    } else if (x > note.endTime) {\n        return sin( (portaMiddleTime(note.endTime,note)/note.endFreq*note.startFreq + x-note.endTime) * note.endFreq );\n    } else {\n        return sin(portaMiddleTime(x,note)*note.startFreq);\n    }\n    \n}\n\n\n\n\n\n\n\nfloat spookyLead(float time){\n    \n    const float bps = 3.25;\n    float beatTime = (time*bps);\n    \n    if (beatTime<0.0) return 0.0;\n    if (beatTime>=16.0) return 0.0;\n    \n    float barTime = mod(beatTime,4.0);\n    int barNum = int(floor(beatTime/4.0));\n    int startNote, endNote;\n    float startBeat, endBeat;\n    float inBeat, outBeat;\n    float vol = 1.0;\n    \n    if (beatTime<12.0){\n        if (barTime < 3.0) {\n            startBeat = 0.0;\n            endBeat = 3.0;\n            if (barNum == 0) {\n                startNote = 16;\n                endNote = 4;\n            } else if (barNum == 1) {\n                startNote = 22;\n                endNote = 27;\n            } else if (barNum == 2) {\n                startNote = 1;\n                endNote = 6;\n            }\n        } else {\n            startBeat = 3.0;\n            endBeat = 4.0;\n            if (barNum == 0) {\n                startNote = 9;\n                endNote = 10;\n            } else if (barNum == 1) {\n                startNote = -8;\n                endNote = -7;\n                vol = 1.5;\n            } else if (barNum == 2) {\n                startNote = 23;\n                endNote = 26;\n            }\n        }\n        inBeat = startBeat;\n        outBeat = endBeat;\n    } else {\n        if (beatTime<14.0){\n            inBeat = startBeat = 0.0;\n            endBeat = 1.0;\n            outBeat = 2.0;\n            startNote = -23;\n            endNote = 17;\n        } else {\n            inBeat = startBeat = 2.0;\n            outBeat = endBeat = 4.0;\n            startNote = 4;\n            endNote = -4;\n        }\n    }\n    \n    float tone = playPortamento(mod(time,4.0/bps),portaNote(startNote,endNote,startBeat/bps,endBeat/bps));\n    float fade = 1.0;\n    fade *= min(1.0,(barTime-inBeat)*80.0);\n    fade *= min(1.0,(outBeat-barTime)*80.0);\n    return tone*fade*vol;\n    \n}\n\nconst float heartbeat = 0.63;\nconst float dronebar = heartbeat*4.0;\nconst float muteStart = dronebar*0.98;\nfloat spookyDrone(float time){\n    \n    float fund = noteFreq(-8)*time*pi2 + (1.0-(pow(sin(time*22.0)*0.5+0.5,3.0)))*5.0;\n    \n    return\n        sin(fund)*0.5 +\n        sin(fund*3.0)*0.25 + \n    \tsin(fund*4.0)*0.025;\n}\nfloat spookyBass(float time){\n    \n    const float noteSpace = heartbeat;\n    const float noteLength = noteSpace*0.7;\n    float noteTime = mod(time,noteSpace);\n    float noteNum = floor(time/noteSpace);\n    \n    if (noteTime>noteLength) return 0.0;\n    \n    float tone = sin(noteFreq(-27)*time*pi2);\n    float vol = (mod(noteNum,2.0) < 1.0) ? 1.0 : 0.25;\n    vol *= min(1.0,noteTime*80.0);\n    vol *= min(1.0,(noteLength-noteTime)*80.0);\n    \n    return tone*vol;\n    \n}\n\n\n\n\n\nvec2 caveMusic(float songTime){\n    \n    vec2 mix = vec2(0.0);\n    \n    if (songTime > 0.0) {\n\n        mix += spookyLead(songTime-2.5)*pan(1.0)*0.15;\n        mix += spookyLead(songTime-2.9)*pan(-1.0)*0.15;\n\n        float droneTime = mod(songTime,dronebar);\n        if (droneTime < muteStart) {\n            float droneMute = 1.0;\n            droneMute *= min(1.0,droneTime*80.0);\n            droneMute *= min(1.0,(muteStart-droneTime)*80.0);\n            mix += spookyDrone(droneTime)*pan(1.0)*0.2*droneMute;\n            mix += spookyDrone(droneTime*1.04)*pan(-1.0)*0.2*droneMute;\n        }\n\n        mix += spookyBass(songTime)*pan(0.0)*0.5;\n\n    }\n    \n    return mix;\n    \n}\nvec2 transitionMusic(float introTime){\n    \n    vec2 mix = vec2(0.0);\n    \n    const float numEchos = 3.0;\n    for(float i=0.0; i<numEchos; i++){\n\n        float echoTime = introTime - i*0.03;\n        float echoVol = 1.0-(i/numEchos);\n\n        const float hornOffset = 0.0;\n\n        mix += (\n            (introHorn(-4,echoTime)*1.0*pan(-0.6))+\n            (introHorn( 3,echoTime)*1.0*pan(-0.2))+\n            (introHorn( 5,echoTime)*1.0*pan( 0.2))+\n            (introHorn(10,echoTime)*1.0*pan( 0.6))+\n            (introHorn(14,echoTime)*0.5*pan( 0.0))\n        )*0.5*echoVol;\n    }\n\n\n    float volEnv = cos(pow(introTime*0.5,0.8)*6.2831)*0.5+0.5;\n    const float volEnvMin = 0.3;\n    volEnv = volEnv*(1.0-volEnvMin)+volEnvMin;\n\n\n    float fadeIn = max(0.0,min(1.0,introTime/0.3));\n    fadeIn = 1.0-pow(1.0-fadeIn,2.0);\n\n    const float fadeOutStart = (transitionEnd-transitionStart) - 0.45;\n    const float fadeOutEnd = (transitionEnd-transitionStart) - 0.1;\n    float fadeOut = max(0.0,min(1.0,(introTime-fadeOutStart)/(fadeOutEnd-fadeOutStart)));\n    fadeOut = 1.0-pow(fadeOut,4.0);\n\n    return mix*volEnv*fadeOut*fadeIn;\n    \n}\nvec2 battleMusic(float songTime){\n    \n    float mix = 0.0;\n\n\n    float beatNum = songTime/beatLength;\n    float beatStep = mod(floor(beatNum),32.0);\n    float barStep = floor(beatNum/32.0);\n\n\n    if (barStep == 0.0) {\n        mix += krakenLead(songTime);\n    } else {\n        mix += krakenLead(songTime);\n        mix += krakenLead(songTime-0.1)*0.3;\n    }\n\n\n    if (barStep > 0.0) {\n        if (barStep == 1.0) {\n            if (beatStep < 28.0) {\n                mix += kick(mod(beatNum,4.0))*1.5;\n            } else {\n                mix += kick(mod(beatNum,1.0))*1.5;\n            }\n            float snareHatBeat;\n            float snareHatVol;\n            if (beatStep < 24.0) {\n                snareHatBeat = mod(beatNum,2.0);\n                if (mod(beatStep,8.0) > 4.0) snareHatBeat = mod(beatNum+1.0,2.0);\n                snareHatVol = 1.0;\n            } else {\n                snareHatBeat = mod(beatNum,1.0);\n                snareHatVol = 1.25 + 0.5*((beatStep-24.0)/8.0);\n            }\n            mix += snare(snareHatBeat)*snareHatVol;\n            mix += hihatClosed(snareHatBeat)*0.5*snareHatVol;\n        } else {\n\n            float beatStepHalf = mod(beatStep,16.0);\n\n            if (\n                beatStepHalf ==  0.0 ||\n                beatStepHalf ==  8.0 ||\n                beatStepHalf == 10.0 ||\n                beatStepHalf == 14.0 ||\n                beatStep == 21.0\n            ) {\n                mix += kick(mod(beatNum,1.0))*1.5;\n            }\n\n            if (\n                beatStepHalf ==  4.0 ||\n                beatStepHalf ==  7.0 ||\n                beatStepHalf ==  9.0 ||\n                beatStepHalf == 12.0 \n            ){\n                mix += snare(mod(beatNum,1.0))*1.5;\n            }\n            if (\n                beatStepHalf ==  3.0 ||\n                beatStepHalf == 11.0 ||\n                beatStepHalf == 13.0 \n            ){\n                mix += snare(mod(beatNum,1.0))*0.5;\n            }\n\n            float hihatBeatNum = beatNum-2.0;\n            if (mod(floor(beatStep/2.0),8.0)==4.0) hihatBeatNum += 2.0;\n            mix += hihatOpen(mod(hihatBeatNum,4.0))*0.3;\n\n\n            mix += krakenBass(songTime)*1.15;\n\n            mix += krakenWail(songTime)*0.8;\n            mix += krakenWail(songTime-0.1)*0.4;\n\n\n        }\n    }\n\n\n    const float fadeStart = 128.0;\n    const float fadeEnd = fadeStart+64.0;\n    float fadeOut = max(0.0,min(1.0,(beatNum-fadeStart)/(fadeEnd-fadeStart)));\n    fadeOut = (1.0-fadeOut);\n    fadeOut = 1.0-pow(1.0-fadeOut,2.0);\n\n\n    return vec2(mix)*0.3*fadeOut;\n    \n}\n\n\n\nvec2 mainSound(float time){\n    \n    \n    if (time < encounterStart) {\n        \n        return caveMusic(time);\n        \n    } else if (time < transitionStart) {\n        \n        return vec2(0.0);\n        \n    } else if (time < transitionEnd) {\n        \n        return transitionMusic(time - transitionStart);\n        \n    } else {\n        \n        return battleMusic(time - transitionEnd);\n        \n    }\n    \n    \n}",
				"name": "",
				"description": "",
				"type": "sound"
			}
		]
	}
}