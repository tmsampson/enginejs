{
	"Shader": {
		"ver": "0.1",
		"info": {
			"id": "Mll3W2",
			"date": "1425690278",
			"viewed": 432,
			"name": "@party 2015 invite",
			"username": "jimbo00000",
			"description": "<a href=\"http://atparty-demoscene.net/\" class=\"regular\" target=\"_blank\">http://atparty-demoscene.net/</a> Come and check out the North American Demoscene in Boston on June 19-22, 2015 at MIT's Stata center. Featuring Brian Peiris of <a href=\"https://github.com/brianpeiris/RiftSketch\"  class=\"regular\" target=\"_blank\">RiftSketch</a> fame!",
			"likes": 0,
			"published": 3,
			"flags": 0,
			"tags": [
				"demoscene",
				"party",
				"atparty",
				"invite",
				"boston"
			],
			"hasliked": 0
		},
		"renderpass": [
			{
				"inputs": [],
				"outputs": [],
				"code": "",
				"name": "",
				"description": "",
				"type": "image"
			},
			{
				"inputs": [],
				"outputs": [],
				"code": "// This code ripped entirely from https://www.shadertoy.com/view/MdfXW2\n// Start the party manually by uncommenting below if you don't want to wait.\n//#define PARTY_ON\n\n// @party will take place June 19-22 2015 6PM\nvec4 atPartyDate = vec4(2015., (6.-1.), 19., 18.*60.*60.);\n\n#define PI 3.14159265358979323846\n#define TAU PI*2.\n\n#define C  32.703\n#define CS 34.648\n#define D  36.708\n#define DS 38.891\n#define E  41.203\n#define F  43.654\n#define FS 46.249\n#define G  48.999\n#define GS 51.913\n#define A  55.0\n#define AS 58.270\n#define B  61.735\n\n#define BPM 120.\n\nfloat noise( float x ){\n    return fract(sin(1371.1*x)*43758.5453);\n}\n\n//3 input arpeggiator, with smoothing\nfloat arp(float a, float b, float c, float t, float smooth)\n{\t\n\tfloat ra = mix(0., a, smoothstep(0.333-smooth, .333+smooth, sin(t*TAU)));\n\tfloat rb = mix(0., b, smoothstep(0.333-smooth, .333+smooth, sin(t*TAU-.333*TAU)));\n\tfloat rc = mix(0., c, smoothstep(0.333-smooth, .333+smooth, sin(t*TAU-.666*TAU)));\n\treturn ra+rb+rc;\n}\n \n/* Input:\n\tgate = how long the note is on [-1...1]\n\tsmooth = symmetric attack/release smoothing (a real ADSR would be better)\n    ofst = time offset, [-1...1] 1 is one period\n*/\nfloat seq(float t, float gate, float smooth, float ofst)\n{\n\treturn smoothstep( gate-smooth, gate+smooth,\n                      cos( (t*PI*BPM/120.) - ofst*TAU - PI*0.5 + gate ) );\n}\n\n//same idea but with an AR envelope\nfloat seqAR(float t, float gate, float atk, float rel, float ofst)\n{\n    float p = ((t*PI*BPM/120.)-ofst*TAU-PI*0.5+gate );\n    float tp = fract(p/PI*.5);\n    \n    //The envelopes have to be scaled based on the gate length\n    gate = clamp(gate,-1.,1.);\n    float scl = (1.-abs(gate));\n    atk *= scl;\n    rel *= scl;\n    \n    //Attack envelope\n\tif (tp > 0.5)\n\t\treturn smoothstep( gate-atk, gate+atk, cos(p));\n    //Release envelope\n\telse\n\t\treturn smoothstep( gate-rel, gate+rel, cos(p));\n}\n\n//-------------------------------------------------------------------\n//---------------------------Instruments-----------------------------\n//-------------------------------------------------------------------\n\n//Basic waveforms with note and octave input\nfloat sn(float t, float note, float octave)\n{\n\treturn sin(t*note*exp2(octave)*PI);\n}\n\nfloat saw(float t, float note, float octave)\n{\n\treturn fract(t*note*exp2(octave-1.))-0.5;\n}\n\nfloat tri(float t, float note, float octave)\n{\n\treturn (abs(fract(t*note*exp2(octave-1.))-0.5)*2.-0.5)*2.;\n}\n\nfloat sqr(float t, float note, float octave)\n{\n\treturn step(fract(t*note*exp2(octave-1.)), 0.5)-0.5;\n}\n\n//-------------------------------------------------------------------\n//----------------------------Mixing---------------------------------\n//-------------------------------------------------------------------\n\n//Simple mixing function with balance control  (balance range 0..1)\nvec2 mixb(float x, float bal)\n{\n\tbal = clamp(bal,0.,1.);\n\treturn vec2(x * bal, x*(1.-bal));\n}\n\n\nfloat bassline(float t)\n{\n\tfloat v = 0.;\t\n    float tw = -.01;\n    v += sqr(t,C,2.)\n        * seq(t*8., -0.0, 0., 0.05) // eigth notes\n        * seq(t*.25, .75, 0., tw); // 1 measure(1st/4)\n    v += sqr(t,DS,2.)\n        * seq(t*8., -0.0, 0., 0.05)\n        * seq(t*.25, .75, 0., .25+tw); // 1 measure(2nd/4)\n    v += sqr(t,AS,1.)\n        * seq(t*8., -0.0, 0., 0.05)\n        * seq(t*.25, .75, 0., .5+tw); // 1 measure(3nd/4)\n    v += sqr(t,F,2.)\n        * seq(t*8., -0.0, 0., 0.05)\n        * seq(t*.25, .75, 0., .75+tw); // 1 measure(4th/4)\n    return v;\n}\n\n// NOT general, only works until June\nvec4 getCountdown(vec4 then, vec4 now)\n{\n    int md[6];md[1]=31;md[2]=28;md[3]=31;md[4]=30;md[5]=31;\n    int totalDays = int(then.z);\n    if (int(then.y) == int(now.y))\n    {\n        totalDays -= int(now.z);\n    }\n    else\n    {\n        for (int i=1; i<6; ++i)\n        {\n            if (i >= int(now.y+1.)) totalDays += md[i];\n        }\n        totalDays -= int(now.z);\n    }\n    if (now.w > then.w) totalDays -=1;\n    \n    float secs = now.w;\n    float ds = then.w - now.w;\n    float hours = mod(ds / (60.0 * 60.0), 24.0);\n    float minutes = mod(ds / 60.0, 60.0);\n    float seconds = mod(ds, 60.0);\n    return vec4(float(totalDays), float(hours), minutes, seconds);\n}\n\nvec2 mainSound(float time)\n{\n\tfloat t = time;\n    float party = 0.;\n    vec4 testDate = iDate;\n    vec4 cd = getCountdown(atPartyDate, testDate);\n    float daysleft = cd.x;\n    party = 1.-clamp(daysleft/14.,0.,1.);\n    \n#ifdef PARTY_ON\n    party = 1.;\n#endif\n    //the AR envelope version of the sequencer can be used for basic \"drums\"\n    \n    //kick: low frequency sin with sharp attack and slow release\n    //in this care i'm also modulating the frequency for extra oomph\n    float frq = seqAR(t*4.,.9,1.,1.,0.)*0.05;\n    float v1 = sn(t+frq,A,1.)*seqAR(t*4.,.9,.005,1.,0.);\n    \n    // snare on offbeats\n    v1 += noise(t)*seqAR(1.+t*2., .94, .0001, 0.1, -.02)*0.5;\n\tfloat v2 = bassline(t);\n    \n    //some notes for the arp\n    float nA = sqr(t,A,4.);\n    float nAS = sqr(t,AS,4.);\n    float nB = sqr(t,B,4.);\n    float nC = sqr(t,C,4.);\n    float nD = sqr(t,D,4.);\n    float nDS = sqr(t,DS,4.);\n    float nE = sqr(t,E,4.);\n    float nF = sqr(t,F,4.);\n    float nFs = sqr(t,FS,4.);\n    float nG = sqr(t,G,4.);\n    float nA2 = sqr(t,A,5.);\n    float nAS2 = sqr(t,AS,5.);\n    float nB2 = sqr(t,B,4.);\n    float nC2 = sqr(t,C,5.);\n    float nD2 = sqr(t,D,5.);\n    \n    float arpspeed = t*8.;//16.;\n    float x = t*.125*.25*PI;\n    float cyc = sign(sin(x)) -sign(cos(2.*x));\n    arpspeed = t*mix(4., 8., .5+.5*cyc);\n    float arpgate = 0.5;\n    float ACE = arp(nC,nE,nC2, arpspeed, arpgate);\n    float ABE = arp(nDS,nG,nC2, arpspeed, arpgate);\n    float arp7 = arp(nG,nF,nAS, arpspeed, arpgate);\n    float asus = arp(nA,nDS,nAS, arpspeed, arpgate);\n    float ares = arp(nAS,nD,nD2, arpspeed, arpgate);\n    \n    //some patterns with those arps\n    float t12 = t/2.;\n    const float gat = 0.7;\n    const float sm = 0.05;\n    float pat1 = 0.;\n    pat1 += ACE*seq(t*.25, gat, sm, 0./4.);\n    pat1 += ABE*seq(t*.25, gat, sm, 1./4.);\n    pat1 += arp7*seq(t*.25, gat, sm, 2./4.);\n    pat1 += asus*seq(t*.5, gat, sm, 4./8.)*seq(t*.25, gat, sm, 3./4.);\n    pat1 += ares*seq(t*.5, gat, sm, 6./8.)*seq(t*.25, gat, sm, 3./4.);\n    float v3 = pat1;\n    \n\t//Mixing\n\tvec2 v = vec2(0.);\n    if (party > .1)\n    \tv += mixb(v1*1.5,0.5);\n    if (party > .5)\n\t\tv += mixb(v2*0.25,0.4);\n    if (party > .8)\n\t\tv += mixb(v3*0.25,0.3);\n\treturn v;\n}\n",
				"name": "",
				"description": "",
				"type": "sound"
			}
		]
	}
}