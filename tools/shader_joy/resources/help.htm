<h2>Inputs</h2>
<hr>
<table>
	<tbody><tr><td><b>vec3</b></td><td><b>&nbsp;iResolution</b></td><td>&nbsp;The viewport resolution (z is pixel aspect ratio, usually 1.0)</td></tr>
	<tr><td><b>float</b></td><td><b>&nbsp;iGlobalTime</b></td><td>&nbsp;Current time in seconds</td></tr>
	<tr><td><b>vec4</b></td><td><b>&nbsp;iColour[4]</b></td><td>&nbsp;Colours from colour palettes tab</td></tr>
	<tr><td><b>float</b></td><td><b>&nbsp;iChannelTime[4]</b></td><td>&nbsp;Time for channel in seconds</td></tr>
	<tr><td><b>vec3</b></td><td><b>&nbsp;iChannelResolution[4]</b></td><td>&nbsp;Input texture resolution for each channel</td></tr>
	<tr><td><b>vec4</b></td><td><b>&nbsp;iMouse</b></td><td>&nbsp;xy = current pixel coords (if LMB is down). zw = click pixel</td></tr>
	<tr><td><b>sampler2D</b></td><td><b>&nbsp;iChannel{i}</b></td><td>&nbsp;Sampler for input textures i</td></tr>
	<tr><td><b>vec4</b></td><td><b>&nbsp;iDate</b></td><td>&nbsp;Year, month, day, time in seconds in .xyzw</td></tr>
	</tbody>
</table>

<br>

<h2>Outputs</h2>
<hr>
For image shaders, fragColor is used as output channel. It is not, for now, mandatory but recommended to leave the alpha channel to 1.0.<br>
<br>

<h2>Language:</h2>
<hr>
<ul>
	<li><b>Preprocessor:</b> # #define #undef #if #ifdef #ifndef #else #elif #endif #error #pragma #extension #version #line</li>
	<li><b>Operators:</b> () + - ! * / %	&lt;	&gt;	&lt;= &gt;= == != &amp;&amp;	||</li>
	<li><b>Comments:</b> // /* */</li>
	<li><b>Types:</b> void bool int float vec2 vec3 vec4 bvec2 bvec3 bvec4 ivec2 ivec3 ivec4 mat2 mat3 mat4 sampler2D</li>
	<li><b>Function Parameter Qualifiers:</b> [none], in, out, inout</li>
	<li><b>Global Variable Qualifiers:</b> const</li>
	<li><b>Vector Components:</b> .xyzw .rgba .stpq</li>
	<li><b>Flow Control:</b> if else for return break continue</li>
	<li><b>Output:</b> vec4 fragColor</li>
	<li><b>Input:</b> vec2 fragCoord</li>
</ul>

<br>


<h2>Built-in Functions:</h2>
<hr>
<table>
	<tbody>
		<tr>
			<td>
				<ul>
				<li>type radians (type degrees)</li>
				<li>type degrees (type radians)</li>
				<li>type sin (type angle)</li>
				<li>type cos (type angle)</li>
				<li>type tan (type angle)</li>
				<li>type asin (type x)</li>
				<li>type acos (type x)</li>
				<li>type atan (type y, type x)</li>
				<li>type abs (type x)</li>
				<li>type sign (type x)</li>
				<li>type floor (type x)</li>
				<li>type ceil (type x)</li>
				<li>type fract (type x)</li>
				<li>type mod (type x, float y)</li>
				<li>type mod (type x, type y)</li>
				<li>type min (type x, type y)</li>
				<li>type min (type x, float y)</li>
				<li>type max (type x, type y)</li>
				<li>type max (type x, float y)</li>
				<li>type mix (type x, type y, type a)</li>
				</ul>
			</td>
			<td>
				<ul>
				<li>type atan (type y_over_x)</li>
				<li>type pow (type x, type y)</li>
				<li>type exp (type x)</li>
				<li>type log (type x)</li>
				<li>type exp2 (type x)</li>
				<li>type log2 (type x)</li>
				<li>type sqrt (type x)</li>
				<li>type inversesqrt (type x)</li>
				<li>type mix (type x, type y, float a)</li>
				<li>type step (type edge, type x)</li>
				<li>type step (float edge, type x)</li>
				<li>mat matrixCompMult (mat x, mat y)</li>
				<li>float length (type x)</li>
				<li>float distance (type p0, type p1)</li>
				<li>float dot (type x, type y)</li>
				<li>vec3 cross (vec3 x, vec3 y)</li>
				<li>type normalize (type x)</li>
				<li>type faceforward (type N, type I, type Nref)</li>
				<li>type reflect (type I, type N)</li>
				<li>type refract (type I, type N,float eta)</li>
				</ul>
			</td>
		</tr>
	</tbody>
</table>

<table>
	<tbody>
		<tr>
			<td>
				<ul>
					<li>type clamp (type x, type minV, type maxV)</li>
					<li>type clamp (type x, float minV, float maxV)</li>
					<li>type smoothstep (type a, type b, type x)</li>
					<li>type smoothstep (float a, float b, type x)</li>
					<li>bvec lessThan(vec x, vec y)</li>
					<li>bvec lessThan(ivec x, ivec y)</li>
					<li>bvec lessThanEqual(vec x, vec y)</li>
					<li>bvec lessThanEqual(ivec x, ivec y)</li>
					<li>bvec greaterThan(vec x, vec y)</li>
					<li>bvec greaterThan(ivec x, ivec y)</li>
					<li>bvec greaterThanEqual(vec x, vec y)</li>
					<li>bvec greaterThanEqual(ivec x, ivec y)</li>
					<li>bvec equal(vec x, vec y)</li>
					<li>bvec equal(ivec x, ivec y)</li>
					<li>bvec equal(bvec x, bvec y)</li>
					<li>bvec notEqual(vec x, vec y)</li>
					<li>bvec notEqual(ivec x, ivec y)</li>
					<li>bvec notEqual(bvec x, bvec y)</li>
					<li>bool any(bvec x)</li>
					<li>bool all(bvec x)</li>
					<li>bvec not(bvec x)</li>
				</ul>
			</td>
		</tr>
	</tbody>
</table>

<table>
	<tbody>
		<tr>
			<td>
				<ul>
					<li>vec4 texture2D(sampler2D sampler, vec2 coord )</li>
					<li>vec4 texture2D(sampler2D sampler, vec2 coord, float bias)</li>
					<li>vec4 textureCube(samplerCube sampler, vec3 coord)</li>
					<li>vec4 texture2DProj(sampler2D sampler, vec3 coord )</li>
					<li>vec4 texture2DProj(sampler2D sampler, vec3 coord, float bias)</li>
					<li>vec4 texture2DProj(sampler2D sampler, vec4 coord)</li>
					<li>vec4 texture2DProj(sampler2D sampler, vec4 coord, float bias)</li>
					<li>type dFdx( type x ), dFdy( type x )</li>
					<li>type fwidth( type p )</li>
				</ul>
			</td>
		</tr>
	</tbody>
</table>

<br>

<h2>How-to</h2>
<hr>
<ul>
	<li><b>Use structs:</b> struct myDataType { float occlusion; vec3 color; }; myDataType myData = myDataType(0.7, vec3(1.0, 2.0, 3.0));</li>
	<li><b>Initialize arrays:</b> arrays cannot be initialized in WebGL.</li>
	<li><b>Do conversions:</b> int a = 3; float b = float(a);</li>
	<li><b>Do component swizzling:</b> vec4 a = vec4(1.0,2.0,3.0,4.0); vec4 b = a.zyyw;</li>
	<li><b>Access matrix components:</b> mat4 m; m[1] = vec4(2.0); m[0][0] = 1.0; m[2][3] = 2.0;</li>
</ul>

<br>

<h2>Be careful!</h2>
<hr>
	<ul>
		<li><b>the <i>f</i> suffix for floating pont numbers:</b> 1.0f is illegal in GLSL. You must use 1.0</li>
		<li><b>saturate():</b> saturate(x) doesn't exist in GLSL. Use clamp(x,0.0,1.0) instead</li>
		<li><b>pow/sqrt:</b> please don't feed sqrt() and pow() with negative numbers. Add an abs() or max(0.0,) to the argument</li>
		<li><b>variables:</b> initialize your variables! Don't assume they'll be set to zero by default</li>
		<li><b>functions:</b> don't call your functions the same as some of your variables</li>
	</ul>
<br>
<br>