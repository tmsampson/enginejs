{
	"Shader": {
		"ver": "0.1",
		"info": {
			"id": "4l2XWh",
			"date": "1443297052",
			"viewed": 618,
			"name": "Cross-Galactic Ocean",
			"username": "Klems",
			"description": "The ocean is the vorono√Ø diagram of a distorted grid. The wave sound is a white noise with a low pass filter. Shadertoy seems to cut the sound after a minute, so I added a fadeout. Use your mouse to rotate the camera!",
			"likes": 16,
			"published": 3,
			"flags": 8,
			"tags": [
				"3d",
				"voronoi",
				"raymarch",
				"retro",
				"water",
				"space",
				"80"
			],
			"hasliked": 0
		},
		"renderpass": [
			{
				"inputs": [],
				"outputs": [],
				"code": "",
				"name": "",
				"description": "",
				"type": "image"
			},
			{
				"inputs": [],
				"outputs": [],
				"code": "#define PI 3.1415926535\n\n// comment these define to remove the synth and/or wave sound\n#define SYNTH\n#define WAVE\n\n// octave is an integer number, 0 is some octave, 1 is an octave higher, etc\n// pitch is an integer between 0 and 7\n// fractionnal and negative values are allowed\n// returns a frequency in Hz\nfloat tone(float octave, float pitch) {\n    float baseFreq = 264.0;\n    baseFreq *= pow(2.0, octave); // multiply the frequency by 2 for higher octave\n    baseFreq *= pow(1.1041, pitch); // seventh root of 2\n    return baseFreq;\n}\n\n// 1D version of IQ code, see https://www.shadertoy.com/view/lsf3WH\nfloat hash( float p ){\n\tfloat h = p * 127.1;\n    return fract(sin(h)*43758.5453123);\n}\nfloat perlinNoise( in float x ) {\n    float lower = floor(x);\n    float upper = lower + 1.0;\n    float lowerV = hash(lower);\n    float upperV = hash(upper);\n    return smoothstep(lower, upper, x) * (upperV - lowerV) + lowerV;\n}\n\n// return a different white noise on both channels\n// thanks Dave Hoskins! see https://www.shadertoy.com/view/4djSRW\n#define ITERATIONS 8\n#define MOD3 vec3(443.8975,397.2973, 491.1871)\nvec2 hash22( in vec2 p ) {\n\tvec3 p3 = fract(vec3(p.xyx) * MOD3);\n    p3 += dot(p3.zxy, p3.yxz+19.19);\n    return fract(vec2(p3.x * p3.y, p3.z*p3.x));\n}\nvec2 noise( in float time ) {\n\tvec2 audio = vec2(0.0);\n    for (int t = 0; t < ITERATIONS; t++) {\n        float v = float(t)*3.21239;\n\t\taudio += hash22(vec2(time + v, time*1.423 + v)) * 2.0 - 1.0;\n    }\n    audio /= float(ITERATIONS);\n    return audio;\n}\n\n// do a low pass on the white noise and get the wave sound\n#define SAMPLES 41\nvec2 getWaveSound( in float time ) {\n    // snap to the nearest 1/iSampleRate\n    float period = 1.0 / iSampleRate;\n    time = floor(time/period)*period;\n    float totAmpl = 0.0;\n    vec2 audio = vec2(0);\n    for (int i = 0 ; i < SAMPLES ; i++) {\n        float index = float(i - SAMPLES/2);\n        float currStepF = period * index;\n        vec2 curr = noise(time + currStepF);\n        index /= 2.0; index *= index;\n        float ampl = 1.0 - index;\n        totAmpl += ampl;\n        audio += curr*ampl;\n    }\n    return audio/totAmpl;\n}\n\n// base synth sound\n#define SYNTH_HARMONICS 3\nfloat getSynthBase( in float time, in float freq, in float frac ) {\n    float x = fract(time*freq);\n    float value = 0.0;\n    if ( x < 0.078) {\n        value = 0.692 - smoothstep(0.0, 0.078, x) * 0.588;\n    } else if ( x < 0.346 ) {\n        value = smoothstep(0.078, 0.346, x) * 0.666 + 0.105; \n    } else if ( x < 0.986 ) {\n        value = 0.771 - smoothstep(0.346, 0.986, x) * 0.351;\n    } else {\n        value = smoothstep(0.986, 1.0, x) * 0.272 + 0.420;\n    }\n    value *= 2.7;\n    float totAmpl = 2.7;\n    \n    // add harmonics\n    float mult = time*2.0*PI*freq;\n    for (int i = 0 ; i < SYNTH_HARMONICS ; i++) {\n        float fact = 1.0 / pow(2.0, float(i)); // = 1, = .5, =.25 etc\n        float harm = sin(mult * fact);\n        float ampl = (cos(frac*2.0*PI) * 3.0 + 4.0) * (1.0 - fact) + 3.0;\n       \tvalue += harm * ampl;\n        totAmpl += ampl;\n    }\n    \n    return value / totAmpl;\n}\n\n#define TEMPO 7.0\n\n// partition\nfloat getTone( in float time ) {\n    float timei = floor((time+TEMPO) / TEMPO);\n    return floor((sin(timei*3.95216) * 0.5 + 0.5) * 4.0);\n}\n\n// synth sound\n#define PART_LENGTH 4.0\n#define PART_COUNT 3.0\n#define TOT_PART (PART_LENGTH*PART_COUNT)\nvec2 getSynth( in float time ) {\n    float part = mod(floor(time / TEMPO / PART_LENGTH), PART_COUNT);\n    if (mod(time, TEMPO * TOT_PART) > TEMPO * 7.0) return vec2(0); // add some calm\n    float currentTone = getTone(time);\n    float frac = mod(time, TEMPO);\n    float freq = tone(-2.0+part, currentTone);\n\tfloat ampl = smoothstep(0.0, 2.0, frac) * (1.0 - smoothstep(TEMPO-2.0, TEMPO, frac));\n    float synthBase = ampl * getSynthBase(time, freq, mod(time, TEMPO)/TEMPO);\n    frac = smoothstep(0.0, TEMPO, frac); // stereo panning\n    if ( mod(floor(time / TEMPO), 2.0) < 1.0) frac = 1.0 - frac;\n    return vec2((1.0-frac)*synthBase, 1.0*synthBase);\n}\n\nvec2 mainSound(float time) {\n    vec2 result = vec2(0);\n    \n    #ifdef SYNTH\n    result += smoothstep(0.0, 2.0, time) * getSynth(time);\n    #endif\n    \n    #ifdef WAVE\n    float waveAmpl = sin(time * 0.353) * 0.12 + 0.24;\n    float perlinAmpl = 1.0 - perlinNoise( time * 1.2146 ) * 0.5;\n    result += smoothstep(0.0, 12.0, time) * getWaveSound(time) * waveAmpl * perlinAmpl;\n    #endif\n    \n    return (1.0 - smoothstep(55.0, 60.0, time)) * result;\n}",
				"name": "",
				"description": "",
				"type": "sound"
			}
		]
	}
}