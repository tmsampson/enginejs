<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8" />

		<title>Engine Sample: Standard material system</title>

		<!-- EngineJS -->
		<script type="text/javascript" src="enginejs/jquery.js"></script>
		<script type="text/javascript" src="enginejs/engine.js"></script>

		<!-- Spectrum colour picker -->
		<script src='enginejs/resources/misc/spectrum/spectrum.js'></script>
		<link rel='stylesheet' href='enginejs/resources/misc/spectrum/spectrum.css' />

		<script language="javascript">
		var resources =
		{
			mat_bunny         : { file : "mat/bunny.mat"},
			mat_sponge        : { file : "mat/sponge.mat"},
			mat_plasma        : { file : "mat/plasma.mat"},
			mat_wool          : { file : "mat/wool.mat"},
			mat_shiny_plastic : { file : "mat/shiny-plastic.mat"},
			mat_stone         : { file : "mat/stone.mat"},
			mat_wood          : { file : "mat/wood.mat"},
			mat_snooker_ball  : { file : "mat/snooker-ball.mat"},
			mat_carpet        : { file : "mat/carpet.mat"},

			mdl_bunny         : { file : "model/bunny.obj", scale : 20 },

			mat_shadow        : { file : "mat/shadow.mat"},
		};

		$(document).ready(function()
		{
			var on_init = function()
			{
				// ====================================================================================================================================
				// Misc
				var mtx_trans = mat4.create();
				var model_index = 0;
				var model_rotate_enabled = true;
				var debug_draw_normals = false;

				// ====================================================================================================================================
				// Camera
				var cam = new Engine.Camera.Perspective({ position: [0, 2, 5] });
				cam.AttachHelper(new Engine.Camera.Helper.Roam({ forward : [0, 0, -1] }));

				// ====================================================================================================================================
				// Shadows
				var shadow_type = 2;
				var shadow_rt = Engine.Gfx.CreateRenderTarget("Shadow", 1024, 1024, true);
				var shadow_preview_enabled = false;
				var shadow_cam = new Engine.Camera.Orthographic({ size : [1024, 1024] });
				var shadow_preview_size = [100, 100];
				var shadow_preview_padding = [10, 10];
				var shadow_preview_cam = new Engine.Camera.Orthographic();
				var shadow_preview_program  = Engine.Gfx.CreateShaderProgram(Engine.Resources["vs_general_transformed_uv_flipped"],
				                              Engine.Resources["fs_unlit_textured"]);

				// ====================================================================================================================================
				// Models
				var floor_model = Engine.Resources["ml_floor_tile"];
				var object_models =
				[
					Engine.Geometry.MakeSphere(),
					Engine.Resources["ml_cube"],
					Engine.Geometry.MakePlane({ x_size : 2, z_size : 2}),
				];

				// ====================================================================================================================================
				// Materials
				var floor_material = new Engine.Gfx.Material();
				var material_index = 0;
				var materials =
				[
					resources["mat_sponge"],
					resources["mat_plasma"],
					resources["mat_carpet"],
					resources["mat_shiny_plastic"],
					resources["mat_wool"],
					resources["mat_wood"],
					resources["mat_stone"],
					resources["mat_snooker_ball"],
				];

				// ====================================================================================================================================
				// Light
				var sun =
				{
					model      : Engine.Geometry.MakeSphere(),
					material   : new Engine.Gfx.Material(),
					position   : [0, 5, 0],
					angle      : 1,	// -90 --> 90 arc
					direction  : [ 0, -1, 0 ],
					colour     : [ 0.4, 0.4, 0.4 ],
					arc_radius : [30, 15],
					arc_lift   : 5
				};

				function update_light()
				{
					// Update light angle
					sun.angle -= Engine.Mouse.GetWheelDelta() / 50;
					sun.angle = Engine.Math.Clamp(sun.angle, -90, 90);

					// Update light position
					sun.position[0] = Math.sin(Engine.Math.DegToRad(sun.angle)) * sun.arc_radius[0];
					sun.position[1] = sun.arc_lift + Math.cos(Engine.Math.DegToRad(sun.angle)) * sun.arc_radius[1];

					// Update light direction
					var len = Math.sqrt((sun.position[0] * sun.position[0]) + (sun.position[1]  * sun.position[1]));
					sun.direction = [ -sun.position[0] / len, -sun.position[1] / len, 0 ];

					// Process gamepad input
					//var gamepad = Engine.Gamepad.Pads[0];
					//if(gamepad)
					{
						sun.angle += Engine.Keyboard.IsPressed("u")? -1 : (Engine.Keyboard.IsPressed("i")? 1 : 0);

						// if(gamepad.IsPressed("lt"))
						// {
						// 	sun.colour[0] -= 0.01;
						// 	sun.colour[1] -= 0.01;
						// 	sun.colour[2] -= 0.01;
						// }
						// if(gamepad.IsPressed("rt"))
						// {
						// 	sun.colour[0] += 0.01;
						// 	sun.colour[1] += 0.01;
						// 	sun.colour[2] += 0.01;
						// }
					}
				};

				var DrawModel = function(override_material)
				{
					var mat_index = 0;

					// Bind material
					var material = (override_material == null)? materials[material_index] : override_material;
					Engine.Gfx.BindMaterial(material, sun, override_material == null);

					// Position on grid
					mat4.translate(mtx_trans, Engine.Math.IdentityMatrix, [0, 0, 0]);

					// Rotate?
					if(model_rotate_enabled && !debug_draw_normals)
					{
						mat4.rotate(mtx_trans, mtx_trans, Engine.Time.elapsed_s / 3.0, [0, 1, 0]);
					}

					// Bind transform
					Engine.Gfx.SetShaderProperty("u_trans_world", mtx_trans, Engine.Gfx.SP_MATRIX4);

					if(override_material == null && material != resources["mat_bunny"]) // only bind shadows for main render pass exluding custom plasma shader
					{
						Engine.Gfx.SetShaderProperty("u_shadow_type", shadow_type, Engine.Gfx.SP_INT)
						Engine.Gfx.SetShaderProperty("u_trans_shadow", shadow_cam.mtx_view_proj, Engine.Gfx.SP_MATRIX4);

						// Bind shadow map
						Engine.Gfx.BindTexture(shadow_rt.depth_texture, 3, "u_shadow_map");
					}

					// Draw model
					Engine.Gfx.DrawModel(resources["mdl_bunny"]);
				}

				var RenderMainPass = function()
				{
					// Clear
					Engine.Gfx.Clear(Engine.Colour.Black);
					Engine.Gfx.SetDepthTestMode(Engine.GL.LESS, true);

					// Update & bind camera
					cam.Update();
					Engine.Gfx.BindCamera(cam);

					// Update light
					update_light();

					if(Engine.Keyboard.IsPressed("m", true))
					{
						material_index = (material_index + 1) % materials.length;
					}

					if(Engine.Keyboard.IsPressed("r", true))
					{
						model_rotate_enabled = !model_rotate_enabled;
					}

					// Draw floor
					mat4.scale(mtx_trans, Engine.Math.IdentityMatrix, [100, 1, 100]);
					Engine.Gfx.BindMaterial(floor_material, sun, true);
					Engine.Gfx.SetShaderProperty("u_trans_world", mtx_trans, Engine.Gfx.SP_MATRIX4);
					Engine.Gfx.SetShaderProperty("u_shadow_type", shadow_type, Engine.Gfx.SP_INT)
					Engine.Gfx.SetShaderProperty("u_trans_shadow", shadow_cam.mtx_view_proj, Engine.Gfx.SP_MATRIX4);
					Engine.Gfx.BindTexture(shadow_rt.depth_texture, 3, "u_shadow_map");
					Engine.Gfx.DrawModel(floor_model);

					DrawModel();
				};

				var RenderShadowPass = function()
				{
					Engine.Gfx.BindRenderTarget(shadow_rt);
					var lookat = [0, 0, 0];
					Engine.Gfx.Clear(Engine.Colour.Blue);
					shadow_cam.Update();

					// fix this manual code
					mat4.lookAt(shadow_cam.mtx_view, sun.position, lookat, [0, 0, 1]);
					mat4.ortho(shadow_cam.mtx_proj,-20, 20, -20, 20, -10, 80);
					mat4.multiply(shadow_cam.mtx_view_proj, shadow_cam.mtx_proj, shadow_cam.mtx_view);
					mat4.invert(shadow_cam.mtx_view_inverse, shadow_cam.mtx_view);

					Engine.Gfx.BindCamera(shadow_cam);

					DrawModel(resources["mat_shadow"]);

					Engine.Gfx.UnBindRenderTarget(shadow_rt);
				};

				var on_render = function()
				{
					// Shadow pass
					RenderShadowPass();

					// Main render pass
					RenderMainPass();

					if(Engine.Keyboard.IsPressed("l", true))
					{
						shadow_type = (shadow_type + 1) % 3;
					}

					// Shadow map preview?
					if(Engine.Keyboard.IsPressed("p", true)) { shadow_preview_enabled = !shadow_preview_enabled; }
					if(shadow_preview_enabled)
					{
						shadow_preview_cam.Update();
						Engine.Gfx.BindCamera(shadow_preview_cam);
						Engine.Gfx.BindShaderProgram(shadow_preview_program);
						mat4.translate(mtx_trans, Engine.Math.IdentityMatrix, [ Engine.Canvas.GetWidth() - shadow_preview_size[0] - shadow_preview_padding[0], Engine.Canvas.GetHeight() - shadow_preview_size[1] - shadow_preview_padding[1], 0]);
						mat4.scale(mtx_trans, mtx_trans, [shadow_preview_size[0], shadow_preview_size[1], 0.0]);
						Engine.Gfx.SetShaderProperty("u_trans_world", mtx_trans, Engine.Gfx.SP_MATRIX4);
						Engine.Gfx.BindTexture(shadow_rt.depth_texture, 0);
						Engine.Gfx.DrawQuad();
					}

					// Debug draw normals?
					if(Engine.Keyboard.IsPressed("n", true))
					{
						debug_draw_normals = !debug_draw_normals;
					}
					if(debug_draw_normals)
					{
						var model = resources["mdl_bunny"];
						var prim = model.model_data.primitives[0];
						var verts = prim.vertex_buffers[0].stream;
						var indices = prim.vertex_buffers[1].stream;
						var normals = prim.vertex_buffers[3].stream;
						for(var i = 0; i < indices.length; i +=3)
						{
							var vert_offset = indices[i] * 3;
							var vx = verts[vert_offset + 0];
							var vy = verts[vert_offset + 1];
							var vz = verts[vert_offset + 2];
							var vert = [ vx, vy, vz ];
							var normal = [ normals[vert_offset], normals[vert_offset + 1], normals[vert_offset + 2] ];
							var end = [ vert[0] + normal[0], vert[1] + normal[1], vert[2] + normal[2] ];
							Engine.Debug.DrawLine3D(cam, vert, end, Engine.Colour.Orange, 1);
						}
					}
				};
				return on_render;
			};
			Engine.Init(on_init, resources);
		});
		</script>
	</head>

	<body>
		<canvas width="1024" height="640">
	</body>
</html>