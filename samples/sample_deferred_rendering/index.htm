<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8" />
		<link rel="stylesheet" href="../sample.css">
		
		<title>Engine Sample: Deferred Rendering (requires WEBGL_draw_buffers)</title>

		<!-- EngineJS -->
		<script type="text/javascript" src="enginejs/jquery.js"></script>
		<script type="text/javascript" src="enginejs/engine.js"></script>

		<script language="javascript">
		var resources =
		{
			tx_lava   : { file : "img/lava.jpg" },
			tx_normal : { file : "img/normal.jpg" },
		};

		$(document).ready(function()
		{
			var on_init = function()
			{
				var mtx_trans = mat4.create();
				var mtx_normal = mat3.create();
				var model_cube  = Engine.Resources["ml_cube"];
				var model_floor = Engine.Resources["ml_floor_tile"];
				var program_floor  = Engine.Gfx.CreateShaderProgram(Engine.Resources["vs_basic_transformed"],
				                                                    Engine.Resources["fs_grid_3d_fog"]);
				var program_cube   = Engine.Gfx.CreateShaderProgram(Engine.Resources["vs_basic_transformed_uv_normals"],
				                                                    Engine.Resources["fs_lit_lambertian"]);
				var program_light  = Engine.Gfx.CreateShaderProgram(Engine.Resources["vs_basic_transformed"],
				                                                    Engine.Resources["fs_unlit_colour"]);

				// Setup orbit cam
				var cam = new Engine.Camera.Perspective();
				cam.AttachHelper(new Engine.Camera.Helper.Orbit(
				{
					look_at : [0, 5, 0],
					radius  : [7, 2.5, 30],
					angles  : [Math.PI / 2, Math.PI / 4],
					min_y   : 0.1,
					max_y   : (Math.PI / 2) - 0.1
				}));

				cam.UpdateMatrices();

				var draw_cube = function(x, y, z, rot)
				{
					// Draw cube
					mat4.translate(mtx_trans, Engine.Math.IdentityMatrix, [x,  y, z]);
					mat4.rotate(mtx_trans, mtx_trans, rot, [1, 1, 1]);
					Engine.Gfx.BindShaderProgram(program_cube);
					Engine.Gfx.SetShaderConstant("u_trans_model", mtx_trans, Engine.Gfx.SC_MATRIX4);
					mtx_normal = Engine.Gfx.MakeNormalMatrix(mtx_trans, cam);
					Engine.Gfx.SetShaderConstant("u_trans_normal", mtx_normal, Engine.Gfx.SC_MATRIX3);
					Engine.Gfx.BindTexture(resources["tx_lava"], 0);
					Engine.Gfx.SetShaderConstant("u_light", [light_x, light_y, light_z], Engine.Gfx.SC_VEC3);
					Engine.Gfx.DrawModel(model_cube);
				};

				var draw_light = function(x, y, z)
				{
					// Draw cube
					mat4.translate(mtx_trans, Engine.Math.IdentityMatrix, [x, y, z]);
					mat4.scale(mtx_trans, mtx_trans, [0.5, 0.5, 0.5]);
					Engine.Gfx.BindShaderProgram(program_light);
					Engine.Gfx.SetShaderConstant("u_trans_model", mtx_trans, Engine.Gfx.SC_MATRIX4);
					Engine.Gfx.SetShaderConstant("u_colour", [1, 1, 1, 1], Engine.Gfx.SC_COLOUR);
					Engine.Gfx.DrawModel(model_cube);

					var dbg_light_pos = cam.WorldToCanvas([x, y, z]);
					var dbg_light_right = cam.WorldToCanvas([x + 3, y, z]);
					var dbg_light_up = cam.WorldToCanvas([x, y + 3, z]);
					var dbg_light_forward = cam.WorldToCanvas([x, y, z + 3]);

					Engine.Debug.DrawLine(dbg_light_pos, dbg_light_right, Engine.Colour.Red, 1);
					Engine.Debug.DrawLine(dbg_light_pos, dbg_light_up, Engine.Colour.Green, 1);
					Engine.Debug.DrawLine(dbg_light_pos, dbg_light_forward, Engine.Colour.Blue, 1);
				};

				var light_x = 0, light_y = 10, light_z = 0;
				var update_light = function(info)
				{
					var radius = 20;
					// light_x = -11 + radius * Math.cos(info.elapsed_s) * Math.cos(info.elapsed_s);
					// light_y = ((1 + Math.sin(info.elapsed_s)) / 2) * radius;
					// light_z = radius * Math.sin(info.elapsed_s) * Math.cos(info.elapsed_s);
					// light_x = 0;
					// light_y = 0;
					// light_z = 0;
					if(Engine.Keyboard.IsPressed("w"))
					{
						light_z -= 0.1;
					}
					if(Engine.Keyboard.IsPressed("s"))
					{
						light_z += 0.1;
					}
					if(Engine.Keyboard.IsPressed("a"))
					{
						light_x -= 0.1;
					}
					if(Engine.Keyboard.IsPressed("d"))
					{
						light_x += 0.1;
					}
					if(Engine.Keyboard.IsPressed("up"))
					{
						light_y += 0.1;
					}
					if(Engine.Keyboard.IsPressed("down"))
					{
						light_y -= 0.1;
					}
					draw_light(light_x, light_y, light_z);
				};

				var on_render = function(info)
				{
					Engine.Gfx.Clear(Engine.Colour.Black);
					Engine.Gfx.SetDepthTestMode(Engine.GL.LESS, true);

					// Update & bind camera
					cam.Update(info);
					Engine.Gfx.BindCamera(cam);
					update_light(info);

					// Draw floor
					mat4.scale(mtx_trans, Engine.Math.IdentityMatrix, [100, 0, 100]);
					Engine.Gfx.BindShaderProgram(program_floor);
					Engine.Gfx.SetShaderConstant("u_trans_model", mtx_trans, Engine.Gfx.SC_MATRIX4);
					Engine.Gfx.DrawModel(model_floor);

					// Draw cubes
					for(var i = -5; i <= 5; ++i)
					{
						for(var j = -5; j <= 5; ++j)
						{
							draw_cube(i * 3, 5, j * 3, info.elapsed_s);
						}
					}
				};
				return on_render;
			};
			Engine.Init(on_init, resources);
		});
		</script>
	</head>

	<body style="background-color:black">
		<canvas width="512" height="512"></canvas>
	</body>
</html>