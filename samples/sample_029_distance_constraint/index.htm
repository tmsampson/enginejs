<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8" />
		<link rel="stylesheet" href="../sample.css">
		
		<title>Engine Sample: Distance Constraint</title>

		<!-- EngineJS -->
		<script type="text/javascript" src="enginejs/jquery.js"></script>
		<script type="text/javascript" src="enginejs/engine.js"></script>

		<!-- Scenes -->
		<script type="text/javascript" src="scenes.js"></script>

		<script language="javascript">

		// Scene
		var scene_index = 0;
		var scene_name = "";
		var gravity_enabled = false;
		var gravity = [ 0, -980, 0 ];
		var bodies = [];
		var constraints = [];
		var controlled_body = null;

		// Circle
		var circle_verts =
		{
			attribute_name : "a_pos",
			item_size      : 3,
			draw_mode      : "triangle_fan",
			stream         : generate_circle_verts(40)
		};

		var circle_vbo = null;

		function generate_circle_verts(segment_count)
		{
			var verts = [0.0, 0.0, 0.0]; var theta = (2 * Math.PI) / segment_count;
			for(var i = 0; i <= segment_count; ++i)
			{
				verts.push(Math.cos(theta * i), Math.sin(theta * i), 0.0);
			}
			return verts;
		}

		function render_body(body)
		{
			var mtx_trans = mat4.create();
			Engine.Gfx.BindVertexBuffer(body.vbo);
			mat4.translate(mtx_trans, Engine.Math.IdentityMatrix, body.position);
			mat4.scale(mtx_trans, mtx_trans, body.scale);
			Engine.Gfx.SetShaderProperty("u_trans_world", mtx_trans, Engine.Gfx.SP_MATRIX4);
			Engine.Gfx.SetShaderProperty("u_colour", body.colour, Engine.Gfx.SP_COLOUR);
			Engine.Gfx.DrawArray();
		}

		function render_constraint(constraint)
		{
			var pos_a = constraint.body_a.position;
			var pos_b = constraint.body_b.position;
			var delta = Engine.Vec3.Subtract(pos_b, pos_a);
			var delta_unit = Engine.Vec3.Normalise(delta);
			var midpoint = Engine.Vec3.MultiplyScalar(Engine.Vec3.Add(pos_a, pos_b), 0.5);
			var separation = Engine.Vec3.Length(delta);
			var extent_a = Engine.Vec3.Add(midpoint, Engine.Vec3.MultiplyScalar(delta_unit, constraint.max_separation * -0.5));
			var extent_b = Engine.Vec3.Add(midpoint, Engine.Vec3.MultiplyScalar(delta_unit, constraint.max_separation * 0.5));
			Engine.Debug.DrawLine(extent_a, extent_b, Engine.Colour.Blue, 3);
			Engine.Debug.DrawLine(pos_a, pos_b, Engine.Colour.Orange, 3);
		}

		function make_body(position, scale, mass, colour)
		{
			var body =
			{
				vbo				: circle_vbo,
				position		: position,
				scale			: [scale, scale, 0.0],
				mass			: mass,
				inverse_mass	: 1.0 / mass,
				colour			: colour,
				linear_velocity	: [0, 0, 0],
				linear_drag		: 0.01,
				acceleration	: [0, 0, 0]
			};
			return body;
		}

		function make_constraint(body_a, body_b, min, max)
		{
			var constraint =
			{
				body_a			: body_a,
				body_b			: body_b,
				min_separation	: min,
				max_separation	: max
			};
			return constraint;
		}

		function integrate_body(body, delta_s)
		{
			// Integrate position
			var position_delta = Engine.Vec3.MultiplyScalar(body.linear_velocity, delta_s);
			body.position = Engine.Vec3.Add(body.position, position_delta);

			// Integrate veocity?
			if(body.mass < 100)
			{
				var accel = Engine.Vec3.Add(body.acceleration, gravity_enabled? gravity : [0, 0, 0]);
				var velocity_delta = Engine.Vec3.MultiplyScalar(accel, delta_s);
				body.linear_velocity = Engine.Vec3.Add(body.linear_velocity, velocity_delta);
			}

			// Apply drag
			var drag = body.linear_drag * (gravity_enabled? 1 : 5);
			body.linear_velocity = Engine.Vec3.MultiplyScalar(body.linear_velocity, 1.0 - drag);
		}

		function solve_constraint(constraint, delta_s)
		{
			var pos_a = constraint.body_a.position;
			var pos_b = constraint.body_b.position;

			var separation_vec = Engine.Vec3.Subtract(pos_b, pos_a);
			var separation_dist = Engine.Vec3.Length(separation_vec);

			var desired_sepration = 0.0;
			if(separation_dist > (constraint.max_separation + 0.1))
			{
				desired_sepration = constraint.max_separation;
			}
			else if(separation_dist < (constraint.min_separation - 0.1))
			{
				desired_sepration = constraint.min_separation;
			}
			else
			{
				return;
			}

			var vel_a = constraint.body_a.linear_velocity;
			var vel_b = constraint.body_b.linear_velocity;
			
			var separation_dir = Engine.Vec3.Normalise(separation_vec);

			var relative_velocity = Engine.Vec3.Subtract(vel_b, vel_a);
			var relative_velocity_on_axis = Engine.Vec3.Dot(relative_velocity, separation_dir);
			var dist_delta = separation_dist - desired_sepration;

			var inv_mass_a = constraint.body_a.inverse_mass;
			var inv_mass_b = constraint.body_b.inverse_mass;
			var impulse_magnitude = relative_velocity_on_axis + (dist_delta / delta_s);
			impulse_magnitude /= (inv_mass_a + inv_mass_b);
			var impulse = Engine.Vec3.MultiplyScalar(separation_dir, impulse_magnitude);

			var impulse_a = Engine.Vec3.MultiplyScalar(impulse, inv_mass_a);
			var impulse_b = Engine.Vec3.MultiplyScalar(impulse, inv_mass_b);
			constraint.body_a.linear_velocity = Engine.Vec3.Add(constraint.body_a.linear_velocity, impulse_a);
			constraint.body_b.linear_velocity = Engine.Vec3.Subtract(constraint.body_b.linear_velocity, impulse_b);
		}

		$(document).ready(function()
		{
			Engine.Init(function()
			{
				// Setup VBOs (vertex buffer objects)
				circle_vbo = Engine.Gfx.CreateVertexBuffer(circle_verts);

				// Setup camera / shader program
				var cam = new Engine.Camera.Orthographic();
				var program = Engine.Gfx.CreateShaderProgram(Engine.Resources["vs_general_transformed"],
				                                             Engine.Resources["fs_unlit_colour"]);

				// Setup text
				var text = new Engine.Text2D.TextBox("0",
				{
					prefix : "Scene: ",
					dock   : ["top", "left"],
					colour : "white"
				});

				// Load first scene
				bodies = [];
				constraints = [];
				scenes[0]();

				var on_render = function()
				{
					Engine.Gfx.Clear(Engine.Colour.Black);
					var gamepad = Engine.Gamepad.Pads[0];

					// Update & bind camera
					cam.Update();
					Engine.Gfx.BindCamera(cam);

					// Handle movement
					if(controlled_body != null)
					{
						var fast = Engine.Keyboard.IsPressed("space") || (gamepad && gamepad.IsPressed("b"));
						var move_speed = 20000 * (fast? 3 : 1) * Engine.Time.delta_s;
						if(Engine.Keyboard.IsPressed("a")) { controlled_body.linear_velocity[0] = -move_speed; }
						if(Engine.Keyboard.IsPressed("d")) { controlled_body.linear_velocity[0] = +move_speed; }
						if(Engine.Keyboard.IsPressed("w")) { controlled_body.linear_velocity[1] = +move_speed; }
						if(Engine.Keyboard.IsPressed("s")) { controlled_body.linear_velocity[1] = -move_speed; }

						// Process gamepad input?
						if(gamepad)
						{
							controlled_body.linear_velocity[0] += gamepad.GetLeftStick()[0] * move_speed * 0.2;
							controlled_body.linear_velocity[1] += gamepad.GetLeftStick()[1] * move_speed * 0.2;
						}
					}

					// Update text
					text.Set(scene_name);

					// Shorten constraint?
					if(Engine.Keyboard.IsPressed("o") || (gamepad && gamepad.IsPressed("lt")))
					{
						for(var i = 0; i < constraints.length; ++i)
						{
							if(constraints[i].max_separation > (constraints[i].min_separation + 1))
								constraints[i].max_separation -= 0.5;
						}
					}

					// Lengthen constraint?
					if(Engine.Keyboard.IsPressed("p") || (gamepad && gamepad.IsPressed("rt")))
					{
						for(var i = 0; i < constraints.length; ++i)
							constraints[i].max_separation += 0.5;
					}

					// Toggle gravity
					if(Engine.Keyboard.IsPressed("g", true) || (gamepad && gamepad.IsPressed("y", true)))
					{
						gravity_enabled = !gravity_enabled;
					}

					// Reset scene?
					if(Engine.Keyboard.IsPressed("r", true) || (gamepad && gamepad.IsPressed("a", true)))
					{
						bodies = [];
						constraints = [];
						scenes[scene_index]();
					}

					// Toggle scene?
					var left =  Engine.Keyboard.IsPressed("left", true) || (gamepad && gamepad.IsPressed("lb", true));
					var right =  Engine.Keyboard.IsPressed("right", true) || (gamepad && gamepad.IsPressed("rb", true));
					var toggle_dir = left? -1 : (right? 1 : 0);
					if(toggle_dir != 0)
					{
						scene_index += toggle_dir;
						if(scene_index > scenes.length -1) { scene_index = 0; }
						if(scene_index < 0) { scene_index = scenes.length - 1; }
						bodies = [];
						constraints = [];
						scenes[scene_index]();
					}

					// Solve constraints
					var delta_s = Math.min(Engine.Time.delta_s, 1.0 / 60.0);
					for(var i = 0; i < constraints.length; ++i)
					{
						solve_constraint(constraints[i], delta_s);
					}

					// Integrate bodies
					for(var i = 0; i < bodies.length; ++i)
					{
						integrate_body(bodies[i], delta_s);
					}

					// Render bodies
					Engine.Gfx.BindShaderProgram(program);
					for(var i = 0; i < bodies.length; ++i)
					{
						render_body(bodies[i]);
					}

					// Render constraints
					for(var i = 0; i < constraints.length; ++i)
					{
						render_constraint(constraints[i]);
					}
				};
				return on_render;
			});
		});
		</script>
	</head>

	<body>
		<canvas width="512" height="512"></canvas>
	</body>
</html>