<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8" />

		<title>Engine Sample: Numerical Integration</title>

		<!-- EngineJS -->
		<script type="text/javascript" src="enginejs/jquery.js"></script>
		<script type="text/javascript" src="enginejs/engine.js"></script>

		<!-- Spectrum colour picker -->
		<script src='enginejs/resources/misc/spectrum/spectrum.js'></script>
		<link rel='stylesheet' href='enginejs/resources/misc/spectrum/spectrum.css' />

		<script language="javascript">
		var resources =
		{
			mat_sponge        : { file : "mat/sponge.mat"},
			mat_wool          : { file : "mat/wood.mat"},
			mat_shadow        : { file : "mat/shadow.mat"},
		};

		$(document).ready(function()
		{
			var on_init = function()
			{
				// ====================================================================================================================================
				// Misc
				var mtx_trans = mat4.create();
				var model_index = 0;

				// ====================================================================================================================================
				// Camera
				var cam = new Engine.Camera.Perspective({ position: [0, 4, 15] });
				cam.AttachHelper(new Engine.Camera.Helper.Roam({ forward : [0, 0, -1] }));
				var shadow_rt = Engine.Gfx.CreateRenderTarget("Shadow", 1024, 1024, true);
				var shadow_cam = new Engine.Camera.Orthographic({ size : [1024, 1024] });

				// ====================================================================================================================================
				// Models
				var floor_model = Engine.Resources["ml_cube"];
				var sphere_model = Engine.Geometry.MakeSphere();

				// ====================================================================================================================================
				// Light
				var sun =
				{
					model      : Engine.Geometry.MakeSphere(),
					material   : new Engine.Gfx.Material(),
					position   : [0, 5, 0],
					angle      : 0,	// -90 --> 90 arc
					direction  : [ 0, -1, 0 ],
					colour     : [ 0.6, 0.6, 0.6 ],
					arc_radius : [30, 15],
					arc_lift   : 5
				};

				var sphere_p = [-5, 5, -2,
								0, 3, -2,
								5, 5, -2];
				var sphere_v = [-2, 0, 0,
								2, 0, 0,
								0, 0, 0 ];
				var sphere_p_prev = [0, 0, 0,
								0, 0, 0,
								0, 0, 0 ];
				var sphere_a = [0, -9.8, 0,
								0, -9.8, 0,
								0, -9.8, 0];
				var mass = 0.5;
				var radius = 1;

				var add_sphere = function()
				{
					var pos = [Engine.Math.RandomInteger(-6, 6), Engine.Math.RandomInteger(2, 8), Engine.Math.RandomInteger(-6, 6)];

					for(var i = 0; i < sphere_p.length; i += 3)
					{
						var s1_pos = [ sphere_p[i], sphere_p[i + 1], sphere_p[i + 2]  ];
						var sep = [ s1_pos[0] - pos[0], s1_pos[1] - pos[1], s1_pos[2] - pos[2] ];
						var dist_sqr = (sep[0] * sep[0])  + (sep[1] * sep[1]) + (sep[2] * sep[2]);
						var rad_sum = radius + radius;
						if(dist_sqr < (rad_sum * rad_sum))
							return false;
					}

					sphere_p.push(pos[0], pos[1], pos[2]);
					sphere_v.push(Engine.Math.RandomInteger(-10, 10), Engine.Math.RandomInteger(-10, 10), Engine.Math.RandomInteger(-10, 10));
					sphere_p_prev.push(0, 6, 0);
					sphere_a.push(0, -9.8, 0);
					return true;
				};

				var draw_spheres = function(mat, bind_shadows)
				{
					var colours = 
					[
						Engine.Colour.Black,    
						Engine.Colour.White,    
						Engine.Colour.Red,      
						Engine.Colour.Green,    
						Engine.Colour.DarkGreen,
						Engine.Colour.Blue,     
						Engine.Colour.Orange,   
						Engine.Colour.Pink
					];

					// Update spheres
					for(var i = 0; i < sphere_p.length; i += 3)
					{
						var pos = [ sphere_p[i], sphere_p[i + 1], sphere_p[i + 2]  ];
						var colour = colours[i % colours.length];
						mat.SetColour("albedo_colour", colour);

						mat4.translate(mtx_trans, Engine.Math.IdentityMatrix, pos);
						Engine.Gfx.BindMaterial(mat, sun, bind_shadows);

						if(bind_shadows)
						{
							// Bind shadow config
							Engine.Gfx.SetShaderProperty("shadow_type", 2, Engine.Gfx.SP_INT)
							Engine.Gfx.SetShaderProperty("u_trans_shadow", shadow_cam.mtx_view_proj, Engine.Gfx.SP_MATRIX4);

							// Bind shadow map
							Engine.Gfx.BindTexture(shadow_rt.depth_texture, 3, "shadow_map");
						}

						Engine.Gfx.SetShaderProperty("u_trans_world", mtx_trans, Engine.Gfx.SP_MATRIX4);
						Engine.Gfx.DrawModel(sphere_model);
					}
				}

				var done = false;
				var bounce_spheres = function(i, j, sep, s1_pos, s1_vel, s2_pos, s2_vel)
				{
					//sphere_p[i] = sphere_p_prev[i]; sphere_p[i + 1] = sphere_p_prev[i + 1]; sphere_p[i + 1] = sphere_p_prev[i + 1];
					//Engine.Log("[" + i + "] move back to " +  sphere_p[i + 1]);
					//sphere_p[j] = sphere_p_prev[j]; sphere_p[j + 1] = sphere_p_prev[j + 1]; sphere_p[j + 1] = sphere_p_prev[j + 1];
					//Engine.Log("[" + j + "] move back to " +  sphere_p[j + 1]);
					//done = true;
					//return;

					var n = vec3.fromValues(sep[0], sep[1], sep[2]);
					var sep_dist = (radius + radius - vec3.len(n)) /2.0;
					vec3.normalize(n, n);

					// Move back
					var v1 = vec3.fromValues(sphere_v[i], sphere_v[i + 1], sphere_v[i + 2]);
					vec3.normalize(v1, v1);
					var v2 = vec3.fromValues(sphere_v[j], sphere_v[j + 1], sphere_v[j + 2]);
					vec3.normalize(v2, v2);

					sphere_p[i] += n[0] * sep_dist;
					sphere_p[i+1] += n[1] * sep_dist;
					sphere_p[i+2] += n[2] * sep_dist;
					sphere_p[j] += -n[0] * sep_dist;
					sphere_p[j+1] += -n[1] * sep_dist;
					sphere_p[j+2] += -n[2] * sep_dist;

					// Find the length of the component of each of the movement
					// vectors along n. 
					// a1 = v1 . n
					// a2 = v2 . n
					var v1 = vec3.fromValues(s1_vel[0], s1_vel[1], s1_vel[2]);
					var v2 = vec3.fromValues(s2_vel[0], s2_vel[1], s2_vel[2]);
					
					var a1 = vec3.dot(v1, n);
					var a2 = vec3.dot(v2, n);

					// Using the optimized version,
					// optimizedP =  2(a1 - a2)
					//              -----------
					//                m1 + m2
					var optimizedP = (2.0 * (a1 - a2)) / (mass + mass);

					// Calculate v1', the new movement vector of circle1
					// v1' = v1 - optimizedP * m2 * n
					var m2 = mass;
					var v1_foo = vec3.fromValues(n[0], n[1], n[2]);
					vec3.scale(v1_foo, v1_foo, optimizedP * m2);
					var v1_dash = vec3.fromValues(v1[0], v1[1], v1[2]);
					vec3.subtract(v1_dash, v1_dash, v1_foo);

					// Calculate v2', the new movement vector of circle2
					// v2' = v2 - optimizedP * m1 * n
					var m1 = mass;
					var v2_foo = vec3.fromValues(n[0], n[1], n[2]);
					vec3.scale(v2_foo, v2_foo, optimizedP * m1);
					var v2_dash = vec3.fromValues(v2[0], v2[1], v2[2]);
					vec3.add(v2_dash, v2_dash, v2_foo);

					var bounce = 0.9;
					sphere_v[i + 0] = v1_dash[0] * bounce; //if(sphere_v[i + 0] > 0 && sphere_v[i + 0] < 0.05) { sphere_v[i + 0] = 0.05; } if(sphere_v[i + 0] < 0 && sphere_v[i + 0] > -0.05) { sphere_v[i + 0] = -0.05; }
					sphere_v[i + 1] = v1_dash[1] * bounce; //if(sphere_v[i + 1] > 0 && sphere_v[i + 1] < 0.05) { sphere_v[i + 1] = 0.05; } if(sphere_v[i + 1] < 0 && sphere_v[i + 1] > -0.05) { sphere_v[i + 2] = -0.05; }
					sphere_v[i + 2] = v1_dash[2] * bounce; //if(sphere_v[i + 2] > 0 && sphere_v[i + 2] < 0.05) { sphere_v[i + 2] = 0.05; } if(sphere_v[i + 2] < 0 && sphere_v[i + 2] > -0.05) { sphere_v[i + 2] = -0.05; }

					sphere_v[j + 0] = v2_dash[0] * bounce; //if(sphere_v[j + 0] > 0 && sphere_v[j + 0] < 0.05) { sphere_v[j + 0] = 0.05; } if(sphere_v[j + 0] < 0 && sphere_v[j + 0] > -0.05) { sphere_v[j + 0] = -0.05; }
					sphere_v[j + 1] = v2_dash[1] * bounce; //if(sphere_v[j + 1] > 0 && sphere_v[j + 1] < 0.05) { sphere_v[j + 1] = 0.05; } if(sphere_v[j + 1] < 0 && sphere_v[j + 1] > -0.05) { sphere_v[j + 1] = -0.05; }
					sphere_v[j + 2] = v2_dash[2] * bounce; //if(sphere_v[j + 2] > 0 && sphere_v[j + 2] < 0.05) { sphere_v[j + 2] = 0.05; } if(sphere_v[j + 2] < 0 && sphere_v[j + 2] > -0.05) { sphere_v[j + 2] = -0.05; }
				}

				var on_render = function()
				{
					Engine.Gfx.Clear(Engine.Colour.Blue);
					Engine.Gfx.SetDepthTestMode(Engine.GL.LESS, true);

					var dt = 1/60;//Engine.Time.delta_s;

					if(Engine.Keyboard.IsPressed("space", true))
					{
						var ok = false;
						while(!ok)
						{
							ok = add_sphere();
						}
					}

					// Update spheres
					if(!done)
					{
						for(var i = 0; i < sphere_p.length; i += 3)
						{
							// Cache
							sphere_p_prev[i] = sphere_p[i]; sphere_p_prev[i + 1] = sphere_p[i + 1]; sphere_p_prev[i + 2] = sphere_p[i + 2];

							// Load
							var pos = [ sphere_p[i], sphere_p[i + 1], sphere_p[i + 2]  ];
							var vel = [ sphere_v[i], sphere_v[i + 1], sphere_v[i + 2]  ];
							var acc = [ sphere_a[i], sphere_a[i + 1], sphere_a[i + 2]  ];

							
							var bounce = 0.7;
							if(pos[1] <= 1.0) // Bounce floor
							{
								pos[1] = 1;
								vel[1] = -vel[1] * bounce;
							}
							else if(pos[1] >= 20.0) // Bounce lid
							{
								pos[1] = 20;
								vel[1] = -vel[1] * bounce;
							}
							if(pos[0] <= -10) // Bounce left
							{
								pos[0] = -10;
								vel[0] = -vel[0] * bounce;
							}
							else if(pos[0] >= 10.0) // Bounce right
							{
								pos[0] = 10;
								vel[0] = -vel[0] * bounce;
							}
							if(pos[2] <= -10) // Bounce front
							{
								pos[2] = -10;
								vel[2] = -vel[2] * bounce;
							}
							else if(pos[2] >= 10.0) // Bounce back
							{
								pos[2] = 10;
								vel[2] = -vel[2] * bounce;
							}

							// Update
							pos[0] += vel[0] * dt; pos[1] += vel[1] * dt; pos[2] += vel[2] * dt;
							vel[0] += (acc[0] / mass) * dt; vel[1] += (acc[1] / mass) * dt; vel[2] += (acc[2] / mass) * dt;

							// store
							sphere_p[i] = pos[0]; sphere_p[i + 1] = pos[1]; sphere_p[i + 2] = pos[2];
							sphere_v[i] = vel[0]; sphere_v[i + 1] = vel[1]; sphere_v[i + 2] = vel[2];
							sphere_a[i] = acc[0]; sphere_a[i + 1] = acc[1]; sphere_a[i + 2] = acc[2];

							Engine.Log("[" + i + "] y = " + sphere_p[i + 1]);
						}

						// Resolve collisions
						var collision = true;
						var count = 0;
						//while(collision)
						//{
							//collision = false;
							for(var i = 0; i < sphere_p.length; i += 3)
							{
								var s1_pos = [ sphere_p[i], sphere_p[i + 1], sphere_p[i + 2]  ];
								var s1_vel = [ sphere_v[i], sphere_v[i + 1], sphere_v[i + 2]  ];
								for(var j = i + 3; j < sphere_p.length; j += 3)
								{
									var s2_pos = [ sphere_p[j], sphere_p[j + 1], sphere_p[j + 2]  ];
									var s2_vel = [ sphere_v[j], sphere_v[j + 1], sphere_v[j + 2]  ];

									var sep = [ s1_pos[0] - s2_pos[0], s1_pos[1] - s2_pos[1], s1_pos[2] - s2_pos[2] ];
									var dist_sqr = (sep[0] * sep[0])  + (sep[1] * sep[1]) + (sep[2] * sep[2]);
									var rad_sum = radius + radius;
									if(dist_sqr < (rad_sum * rad_sum))
									{
										//collision = true;
										Engine.Log("[" + i + "] prev y = " + sphere_p_prev[i + 1]);
										bounce_spheres(i, j, sep, s1_pos, s1_vel, s2_pos, s2_vel);
									}
								}
							}
							//++count;
							//Engine.Log("count = " + count);
						//}
					}

					// Render shadows
					Engine.Gfx.BindRenderTarget(shadow_rt);
					var lookat = [0, 0, 0];
					Engine.Gfx.Clear(Engine.Colour.Blue);
					shadow_cam.Update();

					// fix this manual code
					mat4.lookAt(shadow_cam.mtx_view, sun.position, lookat, [0, 0, 1]);
					mat4.ortho(shadow_cam.mtx_proj,-50, 50, -50, 50, -10, 80);
					mat4.multiply(shadow_cam.mtx_view_proj, shadow_cam.mtx_proj, shadow_cam.mtx_view);
					mat4.invert(shadow_cam.mtx_view_inverse, shadow_cam.mtx_view);

					Engine.Gfx.BindCamera(shadow_cam);

					draw_spheres(resources["mat_shadow"]);

					Engine.Gfx.UnBindRenderTarget(shadow_rt);

					// Render main
					cam.Update();
					Engine.Gfx.BindCamera(cam);

					// Draw floor
					mat4.scale(mtx_trans, Engine.Math.IdentityMatrix, [100, 0, 100]);
					Engine.Gfx.BindMaterial(resources["mat_wool"], sun, true);
					Engine.Gfx.SetShaderProperty("shadow_type", 2, Engine.Gfx.SP_INT)
					Engine.Gfx.SetShaderProperty("u_trans_shadow", shadow_cam.mtx_view_proj, Engine.Gfx.SP_MATRIX4);

					// Bind shadow map
					Engine.Gfx.BindTexture(shadow_rt.depth_texture, 3, "shadow_map");
					Engine.Gfx.SetShaderProperty("u_trans_world", mtx_trans, Engine.Gfx.SP_MATRIX4);
					Engine.Gfx.DrawModel(floor_model);

					draw_spheres(resources["mat_sponge"], true);

				};
				return on_render;
			};
			Engine.Init(on_init, resources);
		});
		</script>
	</head>

	<body>
		<canvas width="1024" height="640">
	</body>
</html>